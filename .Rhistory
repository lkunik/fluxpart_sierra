num_records <- length(which(!is.na(y95_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U95[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U95[week] <- uncert
}
}
} #end rolling window for-loop
E0_v_U05
E0_v_U05_top3 <- head(E0_v_U05[order(unc_v_U05)], 3)
E0_v_U50_top3 <- head(E0_v_U50[order(unc_v_U50)], 3)
E0_v_U95_top3 <- head(E0_v_U95[order(unc_v_U95)], 3)
E0_annual[[toString(year)]][1] <- mean(E0_v_U05_top3, na.rm = T)
E0_annual[[toString(year)]][2] <- mean(E0_v_U50_top3, na.rm = T)
E0_annual[[toString(year)]][3] <- mean(E0_v_U95_top3, na.rm = T)
E0_annual
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/2_get_E0_vals.r")
traceback()
file
itrim
mod50_primer
mod50_resid
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod50_resid < quantile(mod50_resid, resid_low) |
mod50_resid > quantile(mod50_resid, resid_high))
y50_trim <- y50
y50_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod50 <- minpack.lm::nlsLM(y50_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
week
dat.window
source("config.r")
# list of variables to keep in the moving window dataframe (keep things trim within the loops)
window.vars <- c("posix_time", "Week", "Tair_K", "PPFD", "NEE_U05_f", "NEE_U50_f",
"NEE_U95_f", "AMT_K", "AMNT_K")
# robustness parameters
window_buff <- floor(length_window_days_pass1/7/2) #+/- number of WEEKS from center day to form moving window
# get list of all files that exist
files.list <- lapply(site.list, FUN = function(x) list.files(data.main, pattern = x))
names(files.list) <- site.list
# Loop through each site
for(site in site.list){
site.files <- files.list[[site]] #get files corresponding to this site
# Create object to hold the E0 values as we loop through this site's years of data
E0_annual <- data.frame(matrix(NA, nrow = 3, ncol = length(site.files))) #3 rows for 5, 50 and 95% u* thresholds
rownames(E0_annual) <- c("U05", "U50", "U95")
# for this site, loop through all the available data files (1 per year)
for(file in site.files){
message(paste0("Loading file: ", file)) #print to console to give some play by play
### Prepare Data for partitioning
# read data
dat <- readRDS(paste0(data.main, file))
year <- dat$Year[1]
iyear <- which(site.files %in% file)
colnames(E0_annual)[iyear] <- toString(year)
# now filter data for nighttime only data
dat.night <- dat %>%
filter(daynight == "night")
# create week column
dat.night %<>%
mutate(Week = lubridate::week(posix_time)) %>%
relocate(Week, .after = Year)
# take weekly average dataframe
weekly.df <- dat.night %>%
group_by(Week) %>%
summarize_all(mean, na.rm = T)
# Define the Week of Year windows based on length of moving window
dat.WoY_windows <- seq(from = min(weekly.df$Week, na.rm=T) + window_buff,
to = max(weekly.df$Week, na.rm=T) - window_buff)
# Set up empty vectors for E0, Rref to be filled in the next for-loop
E0_v_U05 <- unc_v_U05 <- E0_v_U50 <- unc_v_U50 <- E0_v_U95 <- unc_v_U95 <-
rep(NA, nweeks)
###########################################################
## Loop through moving window and solve for fit parameters
###########################################################
message(paste0("Calculating daily estimates of E_0 for file: ", file))
# Loop through the moving window
for(week in dat.WoY_windows){
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
if(!all(is.na(y05))){
# run first round of model and assign to object
mod05_primer <- minpack.lm::nlsLM(y05 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod05_resid <- resid(mod05_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod05_resid < quantile(mod05_resid, resid_low) |
mod05_resid > quantile(mod05_resid, resid_high))
y05_trim <- y05
y05_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod05 <- minpack.lm::nlsLM(y05_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
#use broomExtra to capture model output parameters
tidymod05 <- broomExtra::tidy(mod05)
E0_est <- tidymod05$estimate[2]
uncert <- tidymod05$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y05_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U05[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U05[week] <- uncert
}
}
if(!all(is.na(y50))){
# run first round of model and assign to object
mod50_primer <- minpack.lm::nlsLM(y50 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod50_resid <- resid(mod50_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod50_resid < quantile(mod50_resid, resid_low) |
mod50_resid > quantile(mod50_resid, resid_high))
y50_trim <- y50
y50_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod50 <- minpack.lm::nlsLM(y50_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod50 <-broomExtra::tidy(mod50)
E0_est <- tidymod50$estimate[2]
uncert <- tidymod50$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y50_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U50[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U50[week] <- uncert
}
}
if(!all(is.na(y95))){
# run first round of model and assign to object
mod95_primer <- minpack.lm::nlsLM(y95 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod95_resid <- resid(mod95_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod95_resid < quantile(mod95_resid, resid_low) |
mod95_resid > quantile(mod95_resid, resid_high))
y95_trim <- y95
y95_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod95 <- minpack.lm::nlsLM(y95_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod95 <-broomExtra::tidy(mod95)
E0_est <- tidymod95$estimate[2]
uncert <- tidymod95$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y95_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U95[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U95[week] <- uncert
}
}
} #end rolling window for-loop
#get the 3 least uncertain values of E0 for each u* threshold
E0_v_U05_top3 <- head(E0_v_U05[order(unc_v_U05)], 3)
E0_v_U50_top3 <- head(E0_v_U50[order(unc_v_U50)], 3)
E0_v_U95_top3 <- head(E0_v_U95[order(unc_v_U95)], 3)
E0_annual[[toString(year)]][1] <- mean(E0_v_U05_top3, na.rm = T)
E0_annual[[toString(year)]][2] <- mean(E0_v_U50_top3, na.rm = T)
E0_annual[[toString(year)]][3] <- mean(E0_v_U95_top3, na.rm = T)
} #end this site's files for-loop
# Save annual E0 vals
outfile <- paste0(data.E0.case, site, "_E0_annual_df.rds")
saveRDS(E0_annual, outfile)
} #end sites for-loop
isValid
temp_range
week
file
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
Tref_K
x
y05
Tair_K
x
y50
# run first round of model and assign to object
mod05_primer <- minpack.lm::nlsLM(y05 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod05_resid <- resid(mod05_primer)
mod05_resid
dat.window
# Loop through the moving window
for(week in dat.WoY_windows){
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
if(length(x) < 4 | length(y05) < 4 | length(y05) < 4 | length(y05) < 4)
next
if(!all(is.na(y05))){
# run first round of model and assign to object
mod05_primer <- minpack.lm::nlsLM(y05 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod05_resid <- resid(mod05_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod05_resid < quantile(mod05_resid, resid_low) |
mod05_resid > quantile(mod05_resid, resid_high))
y05_trim <- y05
y05_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod05 <- minpack.lm::nlsLM(y05_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
#use broomExtra to capture model output parameters
tidymod05 <- broomExtra::tidy(mod05)
E0_est <- tidymod05$estimate[2]
uncert <- tidymod05$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y05_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U05[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U05[week] <- uncert
}
}
if(!all(is.na(y50))){
# run first round of model and assign to object
mod50_primer <- minpack.lm::nlsLM(y50 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod50_resid <- resid(mod50_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod50_resid < quantile(mod50_resid, resid_low) |
mod50_resid > quantile(mod50_resid, resid_high))
y50_trim <- y50
y50_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod50 <- minpack.lm::nlsLM(y50_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod50 <-broomExtra::tidy(mod50)
E0_est <- tidymod50$estimate[2]
uncert <- tidymod50$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y50_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U50[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U50[week] <- uncert
}
}
if(!all(is.na(y95))){
# run first round of model and assign to object
mod95_primer <- minpack.lm::nlsLM(y95 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod95_resid <- resid(mod95_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod95_resid < quantile(mod95_resid, resid_low) |
mod95_resid > quantile(mod95_resid, resid_high))
y95_trim <- y95
y95_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod95 <- minpack.lm::nlsLM(y95_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod95 <-broomExtra::tidy(mod95)
E0_est <- tidymod95$estimate[2]
uncert <- tidymod95$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y95_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U95[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U95[week] <- uncert
}
}
} #end rolling window for-loop
week
# run first round of model and assign to object
mod05_primer <- minpack.lm::nlsLM(y05 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod05_resid <- resid(mod05_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod05_resid < quantile(mod05_resid, resid_low) |
mod05_resid > quantile(mod05_resid, resid_high))
y05_trim <- y05
y05_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod05 <- minpack.lm::nlsLM(y05_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
nrow(dat.window)
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
# Loop through the moving window
for(week in dat.WoY_windows){
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
if(length(!is.na(x)) < 4 | length(!is.na(y05)) < 4 |
length(!is.na(y05)) < 4 | length(!is.na(y05)) < 4)
next
if(!all(is.na(y05))){
# run first round of model and assign to object
mod05_primer <- minpack.lm::nlsLM(y05 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod05_resid <- resid(mod05_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod05_resid < quantile(mod05_resid, resid_low) |
mod05_resid > quantile(mod05_resid, resid_high))
y05_trim <- y05
y05_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod05 <- minpack.lm::nlsLM(y05_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
#use broomExtra to capture model output parameters
tidymod05 <- broomExtra::tidy(mod05)
E0_est <- tidymod05$estimate[2]
uncert <- tidymod05$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y05_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U05[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U05[week] <- uncert
}
}
if(!all(is.na(y50))){
# run first round of model and assign to object
mod50_primer <- minpack.lm::nlsLM(y50 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod50_resid <- resid(mod50_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod50_resid < quantile(mod50_resid, resid_low) |
mod50_resid > quantile(mod50_resid, resid_high))
y50_trim <- y50
y50_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod50 <- minpack.lm::nlsLM(y50_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod50 <-broomExtra::tidy(mod50)
E0_est <- tidymod50$estimate[2]
uncert <- tidymod50$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y50_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U50[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U50[week] <- uncert
}
}
if(!all(is.na(y95))){
# run first round of model and assign to object
mod95_primer <- minpack.lm::nlsLM(y95 ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
mod95_resid <- resid(mod95_primer)
# Trim the first round of model to exclude upper and lower 5% of residuals
itrim <- which(mod95_resid < quantile(mod95_resid, resid_low) |
mod95_resid > quantile(mod95_resid, resid_high))
y95_trim <- y95
y95_trim[itrim] <- NA
## Rerun model on trimmed dataset
mod95 <- minpack.lm::nlsLM(y95_trim ~ fNight_Reichstein(Temp = x, Rref, Tref = Tref_K,
T0 = T0_K, E0), start = list(Rref = 1, E0 = 100), model = TRUE)
# use broomExtra to capture model output parameters
tidymod95 <-broomExtra::tidy(mod95)
E0_est <- tidymod95$estimate[2]
uncert <- tidymod95$std.error[2]
# Now get stats on temperature range, # of records and temp sensitivity
# to determine if estimate is valid
temp_range <- diff(range(x[-itrim], na.rm = T))
num_records <- length(which(!is.na(y95_trim)))
isValid <- (temp_range > min_T_range) & (num_records > min_records) &
(E0_est > E0_low) & (E0_est < E0_high)
if(isValid){
E0_v_U95[week] <- E0_est # save the daily estimated parameter into E0 vector
unc_v_U95[week] <- uncert
}
}
} #end rolling window for-loop
week
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
x
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/2_get_E0_vals.r")
dat
which(is.nan(dat)))
which(is.nan(dat))
sapply(dat, function(x) sum(is.nan(x)))
sum(sapply(dat, function(x) sum(is.nan(x))))
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/2_get_E0_vals.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/2_get_E0_vals.r")
week
#Filter data for this window
WoY_window <- seq(week - window_buff, week + window_buff)
dat.window <- weekly.df %>%
filter(Week %in% WoY_window) %>%
select(any_of(window.vars))
# if not a sufficient number of entries, skip
if(nrow(dat.window) < 4)
next
x <- dat.window$Tair_K #grab your "x variable", i.e. input to Reco function
y05 <- dat.window$NEE_U05_f #grab your "y variable", i.e. output to Reco function
y50 <- dat.window$NEE_U50_f #grab your "y variable", i.e. output to Reco function
y95 <- dat.window$NEE_U95_f #grab your "y variable", i.e. output to Reco function
Tref_K <- unique(dat.window$AMNT_K) #can only be one value
length(!is.na(x))
x
is.na(x)
!is.na(x)
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/2_get_E0_vals.r")
warnings()
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/3_flux_part.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/5_plot_Rref_E0.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/1.3_weekly_NEETemp_annual_E0/fluxpart_sierra/6_compare_NWR.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/0_run_all.r")
100/7
14/52
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
debugSource("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
debugSource("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/3_flux_part.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Eddy_Covariance/Flux_part/sierra/baseline/4_combine_years.r")
source("~/Documents/Climate Dynamics/HW1/HW1.r")
dTdt_yr
